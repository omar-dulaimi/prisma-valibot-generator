import type { DMMF, GeneratorOptions } from '@prisma/generator-helper';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import logger from './utils/logger';
import removeDir from './utils/removeDir';

// Minimal Valibot generator per MVP PRD

function isScalarOrEnum(field: DMMF.Field): boolean {
  return field.kind === 'scalar' || field.kind === 'enum';
}

function getUsedEnumNames(model: DMMF.Model): string[] {
  return Array.from(
    new Set(
      model.fields.filter((f) => f.kind === 'enum').map((f) => String(f.type)),
    ),
  );
}

const SCALAR_TO_V: Record<string, string> = {
  String: 'v.string()',
  Int: 'v.number()',
  Float: 'v.number()',
  Decimal: 'v.union([v.number(), v.string()])',
  Boolean: 'v.boolean()',
  DateTime: 'v.union([v.date(), v.string()])',
  Json: 'v.any()',
  BigInt: 'v.bigint()',
  Bytes: 'v.instance(Uint8Array)',
};

function mapScalar(type: string): string {
  return SCALAR_TO_V[type] ?? 'v.any()';
}

function mapFieldToValibot(
  field: DMMF.Field,
  enums: ReadonlyArray<DMMF.DatamodelEnum>,
): string {
  let base: string;
  const type = String(field.type);

  if (field.kind === 'enum') {
    const enumDef = enums.find((e) => e.name === type);
    if (!enumDef) {
      throw new Error(
        `Enum '${type}' not found in schema. Available enums: ${enums.map((e) => e.name).join(', ')}`,
      );
    }
    const constName = `${type}Enum`;
    base = constName;
  } else if (field.kind === 'scalar') {
    base = mapScalar(type);
  } else {
    throw new Error(
      `Unsupported field kind '${field.kind}' for field '${field.name}'. Only scalar and enum fields are supported.`,
    );
  }

  if (field.isList) {
    base = `v.array(${base})`;
  }

  return base;
}

function modelFilename(modelName: string) {
  return `${modelName}.schema.ts`;
}

function buildObjectSchema(
  name: string,
  fields: ReadonlyArray<DMMF.Field>,
  makeField: (f: DMMF.Field) => string,
): string[] {
  const entries = fields
    .filter(isScalarOrEnum)
    .map((f) => `  ${f.name}: ${makeField(f)}`);
  return [
    `export const ${name} = v.object({`,
    entries.join(',\n'),
    '});',
    `export type ${name}Type = v.InferOutput<typeof ${name}>;`,
    '',
  ];
}

function buildSchemasForModel(
  model: DMMF.Model,
  enums: ReadonlyArray<DMMF.DatamodelEnum>,
): string {
  const lines: string[] = [];
  lines.push('// Generated by prisma-valibot-generator — Do not edit manually');
  lines.push("import * as v from 'valibot';");
  // Import enum schemas if this model uses any
  const usedEnumNames = getUsedEnumNames(model);
  if (usedEnumNames.length > 0) {
    const importNames = usedEnumNames.map((name) => `${name}Enum`).join(', ');
    lines.push(`import { ${importNames} } from './enums';`);
  }
  lines.push('');

  // Full model (nullable fields handled correctly)
  lines.push(
    ...buildObjectSchema(`${model.name}Schema`, model.fields, (f) => {
      const base = mapFieldToValibot(f, enums);
      return f.isRequired ? base : `v.nullable(${base})`;
    }),
  );

  // Create validator (required fields only — heuristic: required w/o default/id/updatedAt)
  const createFields = model.fields.filter(
    (f) =>
      isScalarOrEnum(f) &&
      f.isRequired &&
      !f.hasDefaultValue &&
      !f.isId &&
      !f.isUpdatedAt,
  );
  lines.push(
    ...buildObjectSchema(`Create${model.name}Schema`, createFields, (f) =>
      mapFieldToValibot(f, enums),
    ),
  );

  // Update validator (all fields optional)
  lines.push(
    ...buildObjectSchema(
      `Update${model.name}Schema`,
      model.fields,
      (f) => `v.optional(${mapFieldToValibot(f, enums)})`,
    ),
  );

  return lines.join('\n');
}

interface EnumValue {
  name: string;
  dbName?: string | null;
}

function isValidEnumValue(val: unknown): val is EnumValue {
  return (
    typeof val === 'object' &&
    val !== null &&
    'name' in val &&
    typeof (val as EnumValue).name === 'string'
  );
}

function buildEnumsFile(
  enums: ReadonlyArray<DMMF.DatamodelEnum>,
  enumValueMode: 'name' | 'dbName',
): string {
  const pickValue = (val: EnumValue): string => {
    if (enumValueMode === 'dbName') {
      return val.dbName ?? val.name;
    }
    return val.name;
  };

  const lines: string[] = [];
  lines.push('// Generated by prisma-valibot-generator — Do not edit manually');
  lines.push("import * as v from 'valibot';");
  lines.push('');

  for (const enm of enums) {
    if (enm.values.length === 0) {
      throw new Error(
        `Enum '${enm.name}' has no values. Enums must have at least one value.`,
      );
    }

    const validatedValues = enm.values.map((val) => {
      if (!isValidEnumValue(val)) {
        throw new Error(
          `Invalid enum value in '${enm.name}': expected object with 'name' property, got ${typeof val}`,
        );
      }
      return val;
    });

    const uniqueValues = Array.from(
      new Set(validatedValues.map((val) => pickValue(val))),
    );
    const valuesList = uniqueValues.map((val) => `'${val}'`).join(', ');
    const valuesConst = `${enm.name}Values`;
    const constName = `${enm.name}Enum`;
    lines.push(`export const ${valuesConst} = [${valuesList}] as const;`);
    lines.push(`export type ${enm.name}Value = typeof ${valuesConst}[number];`);
    lines.push(`export const ${constName} = v.picklist(${valuesConst});`);
    lines.push(
      `export type ${enm.name}Type = v.InferOutput<typeof ${constName}>;`,
    );
    lines.push('');
  }
  return lines.join('\n');
}

function validateConfig(
  config: Record<string, unknown> | undefined,
): 'name' | 'dbName' {
  if (!config?.enumValue) {
    return 'name'; // default
  }

  const enumValue = config.enumValue;
  if (enumValue !== 'name' && enumValue !== 'dbName') {
    throw new Error(
      `Invalid enumValue config: '${enumValue}'. Must be 'name' or 'dbName'.`,
    );
  }

  return enumValue;
}

export async function generateValibot(options: GeneratorOptions) {
  logger.debug('[prisma-valibot] Starting generation');

  try {
    const schemaDir = path.dirname(options.schemaPath);
    const explicitOutput = options.generator.output?.value;
    const defaultOutput = path.join(
      process.cwd(),
      'node_modules',
      '.prisma-valibot',
    );
    const outDir = explicitOutput
      ? path.isAbsolute(explicitOutput)
        ? explicitOutput
        : path.join(schemaDir, explicitOutput)
      : defaultOutput;

    const generatedDir = outDir;
    logger.debug(
      '[prisma-valibot] Output directory resolved to:',
      generatedDir,
    );
    await fs.mkdir(generatedDir, { recursive: true });
    await removeDir(generatedDir, true);
    logger.debug('[prisma-valibot] Output directory cleaned');

    const models = options.dmmf.datamodel.models;
    const enums = options.dmmf.datamodel.enums ?? [];
    const enumValueMode = validateConfig(options.generator.config);

    // Generate per-model files
    logger.debug(
      '[prisma-valibot] Generating schemas for models:',
      models.map((m) => m.name),
    );
    for (const model of models) {
      const content = buildSchemasForModel(model, enums);
      const filePath = path.join(generatedDir, modelFilename(model.name));
      await fs.writeFile(filePath, content, 'utf8');
      logger.debug(
        `[prisma-valibot] Wrote schema for model ${model.name} -> ${filePath}`,
      );
    }

    // Generate enums file
    if (enums.length > 0) {
      const enumsContent = buildEnumsFile(enums, enumValueMode);
      await fs.writeFile(
        path.join(generatedDir, 'enums.ts'),
        enumsContent,
        'utf8',
      );
      logger.debug('[prisma-valibot] Wrote enums file');
    }

    // Index barrel
    const indexLines: string[] = [];
    for (const model of models) {
      const fileBase = `./${modelFilename(model.name)}`;
      indexLines.push(`export * from '${fileBase.replace(/\\.ts$/, '')}';`);
    }
    if (enums.length > 0) {
      indexLines.push("export * from './enums';");
    }
    await fs.writeFile(
      path.join(generatedDir, 'index.ts'),
      `${indexLines.join('\n')}\n`,
      'utf8',
    );
    logger.debug('[prisma-valibot] Wrote index barrel');
    logger.info('Prisma Valibot: generation complete');
  } catch (error) {
    logger.error('[prisma-valibot] Generation failed:', error);
    throw error;
  }
}
