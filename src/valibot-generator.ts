import type { DMMF, GeneratorOptions } from '@prisma/generator-helper';
import { promises as fs } from 'fs';
import path from 'path';
import logger from './utils/logger';
import removeDir from './utils/removeDir';

// Minimal Valibot generator per MVP PRD

function mapFieldToValibot(field: DMMF.Field, enums: ReadonlyArray<DMMF.DatamodelEnum>): string {
  // Relations and unsupported treated as any in MVP
  if (field.kind !== 'scalar') {
    return 'v.any()';
  }

  const type = String(field.type);
  switch (type) {
    case 'String':
      return 'v.string()';
    case 'Int':
    case 'Float':
    case 'Decimal':
      return 'v.number()';
    case 'Boolean':
      return 'v.boolean()';
    case 'DateTime':
      return 'v.date()';
    case 'Json':
      return 'v.any()';
    case 'BigInt':
      return 'v.bigint()';
    case 'Bytes':
      return 'v.instance(Uint8Array)';
    default: {
      // Enum or unknown scalar
      const enumDef = enums.find((e) => e.name === type);
      if (enumDef) {
        return `v.union([${enumDef.values
          .map((v) => `v.literal('${v.name}')`)
          .join(', ')}])`;
      }
      return 'v.any()';
    }
  }
}

function modelFilename(modelName: string) {
  return `${modelName}.schema.ts`;
}

function buildSchemasForModel(model: DMMF.Model, enums: ReadonlyArray<DMMF.DatamodelEnum>): string {
  const lines: string[] = [];
  lines.push(`// Generated by prisma-valibot-generator — Do not edit manually`);
  lines.push(`import * as v from 'valibot';`);
  lines.push('');

  // Full model (all fields required)
  const fullFields: string[] = model.fields.map((f) => {
    const base = mapFieldToValibot(f, enums);
    return `  ${f.name}: ${base}`;
  });
  lines.push(`export const ${model.name}Schema = v.object({`);
  lines.push(fullFields.join(',\n'));
  lines.push(`});`);
  lines.push('');

  // Create validator (required fields only — heuristic: required w/o default/id/updatedAt)
  const createFields: string[] = model.fields
    .filter((f) => f.kind === 'scalar' && f.isRequired && !f.hasDefaultValue && !f.isId && !f.isUpdatedAt)
    .map((f) => `  ${f.name}: ${mapFieldToValibot(f, enums)}`);
  lines.push(`export const Create${model.name}Schema = v.object({`);
  lines.push(createFields.join(',\n'));
  lines.push(`});`);
  lines.push('');

  // Update validator (all fields optional)
  const updateFields: string[] = model.fields.map((f) => {
    const inner = mapFieldToValibot(f, enums);
    return `  ${f.name}: v.optional(${inner})`;
  });
  lines.push(`export const Update${model.name}Schema = v.object({`);
  lines.push(updateFields.join(',\n'));
  lines.push(`});`);
  lines.push('');

  return lines.join('\n');
}

export async function generateValibot(options: GeneratorOptions) {
  logger.debug('[prisma-valibot] Starting generation');
  const schemaDir = path.dirname(options.schemaPath);
  const explicitOutput = options.generator.output?.value;
  const defaultOutput = path.join(process.cwd(), 'node_modules', '.prisma-valibot');
  const outDir = explicitOutput
    ? path.isAbsolute(explicitOutput)
      ? explicitOutput
      : path.join(schemaDir, explicitOutput)
    : defaultOutput;

  const generatedDir = outDir;
  logger.debug('[prisma-valibot] Output directory resolved to:', generatedDir);
  await fs.mkdir(generatedDir, { recursive: true });
  await removeDir(generatedDir, true);
  logger.debug('[prisma-valibot] Output directory cleaned');

  const models = options.dmmf.datamodel.models;
  const enums = options.dmmf.datamodel.enums ?? [];

  // Generate per-model files
  logger.debug('[prisma-valibot] Generating schemas for models:', models.map(m => m.name));
  for (const model of models) {
    const content = buildSchemasForModel(model, enums);
    const filePath = path.join(generatedDir, modelFilename(model.name));
    await fs.writeFile(filePath, content, 'utf8');
    logger.debug(`[prisma-valibot] Wrote schema for model ${model.name} -> ${filePath}`);
  }

  // Index barrel
  const indexLines: string[] = [];
  for (const model of models) {
    const fileBase = `./${modelFilename(model.name)}`;
    indexLines.push(`export * from '${fileBase.replace(/\\.ts$/, '')}';`);
  }
  await fs.writeFile(path.join(generatedDir, 'index.ts'), indexLines.join('\n') + '\n', 'utf8');
  logger.debug('[prisma-valibot] Wrote index barrel');
  logger.info('Prisma Valibot: generation complete');
}
